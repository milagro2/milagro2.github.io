<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            background-color: black;
            color: green;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrolling on mobile */
        }

        li {
            list-style: none;
        }

        a {
            color: red;
            font-size: 2vw;
            text-decoration: none;
        }

        a:hover {
            color: green;
        }

        canvas {
            border: 2px solid green;
        }

        #gameOverMessage {
            margin-bottom: 20px;
        }

        #playAgainButton,
        #nextGameButton,
        #autoPlayButton,
        #speedButton {
            margin: 10px;
            padding: 10px;
            font-size: 16px;
        }

        nav {
            background-color: #53535380;
            text-align: center;
            transition: padding 0.3s, position 0, 3s;
        }

        nav ul {
            list-style-type: none;
            padding: 0.3%;
            font-size: 1vw;
        }

        nav li {
            display: inline;
            margin: 0 10px;
        }

        nav a {
            text-decoration: none;
            color: #ffffffba;
            font-weight: bold;
        }

        nav li:hover a {
            color: #ff4800a0;
            transition: color 0.7s ease;
        }
    </style>
</head>

<body>

    <nav id="navbar">
        <ul>
            <li><a href="StHome.php">Home</a></li>
        </ul>
    </nav>

    <canvas id="gameCanvas" width="900" height="700"></canvas>
    <p id="gameOverMessage"></p>
    <button id="playAgainButton" onclick="resetGame()">Play Again</button>
    <button id="nextGameButton" onclick="startNextGame()" style="display: none;">Next Game</button>
    <button id="autoPlayButton" onclick="toggleAutoPlay()">Auto Play</button>
    <button id="speedButton" onclick="toggleSpeed()">Speed Up</button>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const playAgainButton = document.getElementById('playAgainButton');
        const nextGameButton = document.getElementById('nextGameButton');
        const autoPlayButton = document.getElementById('autoPlayButton');
        const speedButton = document.getElementById('speedButton');

        const tableColor = '#3c3c3c';
        const puckColor = '#ff0000';
        const paddleColor = '#0000ff';
        const brickColor = 'white';

        const tableWidth = 900;
        const tableHeight = 700;

        const paddleWidth = 100;
        const paddleHeight = 10;

        let puckX = tableWidth / 2;
        let puckY = tableHeight / 2;
        let puckSpeedX = 5;
        let puckSpeedY = 5;
        let gameStarted = false;

        let paddleX = tableWidth / 2 - paddleWidth / 2;
        let paddleY = tableHeight - 2 * paddleHeight;

        const brickWidth = 100;
        const brickHeight = 20;
        const bricks = [];

        let autoPlay = false;
        let speedUp = false;
        let maxSpeed = 15;
        let intervalId;

        canvas.addEventListener('mousemove', (event) => {
            if (!autoPlay) {
                paddleX = event.clientX - canvas.getBoundingClientRect().left - paddleWidth / 2;
            }
        });

        canvas.addEventListener('touchmove', (event) => {
            if (!autoPlay) {
                const touch = event.touches[0];
                paddleX = touch.clientX - canvas.getBoundingClientRect().left - paddleWidth / 2;
            }
        });

        function toggleAutoPlay() {
            autoPlay = !autoPlay;
            if (autoPlay) {
                autoPlayButton.textContent = 'Manual Play';
                intervalId = setInterval(() => {
                    let closestPuck = null;
                    let minDistance = tableHeight;

                    pucks.forEach((puck) => {
                        if (puck.y > paddleY && puck.y < minDistance) {
                            closestPuck = puck;
                            minDistance = puck.y;
                        }
                    });

                    if (closestPuck) {
                        paddleX = closestPuck.x - paddleWidth / 2;
                    }

                    if (bricks.every((brick) => brick.broken)) {
                        startNextGame();
                        speedUp();
                    }
                }, 10);
            } else {
                autoPlayButton.textContent = 'Auto Play';
                clearInterval(intervalId);
            }
        }

        function toggleSpeed() {
            if (speedUp) {
                puckSpeedX = 5;
                puckSpeedY = 5;
                speedButton.textContent = 'Speed Up';
            } else {
                puckSpeedX = 15;
                puckSpeedY = 15;
                speedButton.textContent = 'Slow Down';
            }
            speedUp = !speedUp;
        }


        function generateBrickGrid(rows, columns) {
            const brickWidthWithPadding = 95;
            const brickHeightWithPadding = 20;
            const padding = 5;

            const totalGridWidth = columns * (brickWidthWithPadding + padding) - padding;
            const initialX = (tableWidth - totalGridWidth) / 2;
            const initialY = 5;

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < columns; j++) {
                    const brickX = initialX + j * (brickWidthWithPadding + padding);
                    const brickY = initialY + i * (brickHeightWithPadding + padding);

                    // Generate random color for each brick
                    const randomColor = "#" + Math.floor(Math.random() * 16777215).toString(16);

                    // Generate random chance for red or grey brick
                    const isRed = Math.random() < 0.1; // 10% chance for red brick

                    bricks.push({
                        x: brickX,
                        y: brickY,
                        width: brickWidthWithPadding - padding,
                        height: brickHeightWithPadding - padding,
                        broken: false,
                        color: isRed ? 'red' : 'grey', // Set color based on chance
                        isGreen: Math.random() < 1 / 3, // 1 in 3 chance for green brick
                    });
                }
            }
        }

        function resetBricks() {
            bricks.length = 0;
            generateBrickGrid(5, 9);
        }

        resetBricks();

        function draw() {
            context.fillStyle = tableColor;
            context.fillRect(0, 0, tableWidth, tableHeight);

            if (gameStarted) {
                puckX += puckSpeedX;
                puckY += puckSpeedY;
            }

            context.fillStyle = puckColor;
            context.beginPath();
            context.arc(puckX, puckY, 10, 0, 2 * Math.PI);
            context.fill();

            context.fillStyle = paddleColor;
            context.fillRect(paddleX, paddleY, paddleWidth, paddleHeight);

            bricks.forEach((brick) => {
                if (!brick.broken) {
                    context.fillStyle = brick.color;
                    context.fillRect(brick.x, brick.y, brick.width, brick.height);
                }
            });

            if (puckY + 10 >= tableHeight) {
                gameOver();
            }

            if (puckY <= 0) {
                puckSpeedY = -puckSpeedY;
            }

            if (puckX <= 0 || puckX >= tableWidth) {
                puckSpeedX = -puckSpeedX;
            }

            if (
                puckY + 10 >= paddleY &&
                puckX >= paddleX &&
                puckX <= paddleX + paddleWidth
            ) {
                puckSpeedY = -puckSpeedY;
            }

            bricks.forEach((brick) => {
                if (!brick.broken) {
                    if (
                        puckY - 10 <= brick.y + brick.height &&
                        puckY - 10 >= brick.y &&
                        puckX >= brick.x &&
                        puckX <= brick.x + brick.width
                    ) {
                        puckSpeedY = -puckSpeedY;
                        brick.broken = true;

                        if (brick.isGreen) {
                            // Spawn a new puck for green brick
                            const newPuckSpeedX = Math.random() < 0.5 ? -5 : 5; // Random direction
                            const newPuckSpeedY = 5;
                            pucks.push({
                                x: brick.x + brick.width / 2,
                                y: brick.y + brick.height / 2,
                                speedX: newPuckSpeedX,
                                speedY: newPuckSpeedY,
                            });
                        }

                        if (bricks.every((brick) => brick.broken)) {
                            gameStarted = false;
                            nextGameButton.style.display = 'block';
                        }
                    }
                }
            });

            // Update and draw green pucks
            pucks.forEach((greenPuck) => {
                greenPuck.x += greenPuck.speedX;
                greenPuck.y += greenPuck.speedY;

                context.fillStyle = puckColor;
                context.beginPath();
                context.arc(greenPuck.x, greenPuck.y, 10, 0, 2 * Math.PI);
                context.fill();

                // Check collisions with walls
                if (greenPuck.x <= 0 || greenPuck.x >= tableWidth) {
                    greenPuck.speedX = -greenPuck.speedX;
                }

                if (greenPuck.y <= 0) {
                    greenPuck.speedY = -greenPuck.speedY;
                }
            });

            // Remove green pucks that go beyond the canvas
            pucks = pucks.filter((greenPuck) => greenPuck.y <= tableHeight);

            requestAnimationFrame(draw);
        }

        function gameOver() {
            context.clearRect(0, 0, tableWidth, tableHeight);
            gameOverMessage.textContent = 'Game Over';
            playAgainButton.style.display = 'block';
        }

        function startNextGame() {
            bricks.length = 0;
            generateBrickGrid(5, 9);
            gameOverMessage.textContent = '';
            playAgainButton.style.display = 'none';
            nextGameButton.style.display = 'none';
            puckX = tableWidth / 2;
            puckY = tableHeight / 2;
            puckSpeedX = 5;
            puckSpeedY = 5;
            gameStarted = true;
        }

        function resetGame() {
            bricks.length = 0;
            generateBrickGrid(5, 9);
            gameOverMessage.textContent = '';
            playAgainButton.style.display = 'none';
            nextGameButton.style.display = 'none';
            puckX = tableWidth / 2;
            puckY = tableHeight / 2;
            puckSpeedX = 5;
            puckSpeedY = 5;
            gameStarted = false;
        }

        canvas.addEventListener('click', function () {
            if (!gameStarted) {
                gameStarted = true;
            }
        });

        let pucks = [];

        draw();
    </script>
</body>

</html>
