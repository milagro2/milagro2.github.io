<!DOCTYPE html>
<html>

<head>
    <style>
        body {
            background-color: black;
            color: green;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
        }

        canvas {
            border: 2px solid green;
        }

        #gameOverMessage {
            margin-bottom: 20px;
        }

        #playAgainButton {
            display: none;
        }

        #nextGameButton {
            display: none;
        }

        #autoPlayButton {
            margin-bottom: 10px;
        }

        #speedButton {
            margin-bottom: 10px;
        }

        nav {
            background-color: #53535380;
            text-align: center;
            transition: padding 0.3s, position 0, 3s;
        }

        nav ul {
            list-style-type: none;
            padding: 0.3%;
            font-size: 1vw;
        }

        nav li {
            display: inline;
            margin: 0 20px;
        }

        nav a {
            text-decoration: none;
            color: #ffffffba;
            font-weight: bold;
        }

        nav li:hover a {
            color: #ff4800a0;
            transition: color 0.7s ease;
        }
    </style>
</head>

<body>

    <li><a href="StHome.php">Home</a></li>

    <canvas id="gameCanvas" width="900" height="700"></canvas>
    <p id="gameOverMessage"></p>
    <button id="playAgainButton" onclick="resetGame()">Play Again</button>
    <button id="nextGameButton" onclick="startNextGame()" style="display: none;">Next Game</button>
    <button id="autoPlayButton" onclick="toggleAutoPlay()">Auto Play</button>
    <button id="speedButton" onclick="toggleSpeed()">Speed Up</button>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const playAgainButton = document.getElementById('playAgainButton');
        const nextGameButton = document.getElementById('nextGameButton');
        const autoPlayButton = document.getElementById('autoPlayButton');
        const speedButton = document.getElementById('speedButton');

        const tableColor = '#3c3c3c';
        const puckColor = '#ff0000';
        const paddleColor = '#0000ff';
        const brickColor = 'white';

        const tableWidth = 900;
        const tableHeight = 700;

        const paddleWidth = 100;
        const paddleHeight = 10;

        let puckX = tableWidth / 2;
        let puckY = tableHeight / 2;
        let puckSpeedX = 5;
        let puckSpeedY = 5;
        let gameStarted = false;

        let paddleX = tableWidth / 2 - paddleWidth / 2;
        let paddleY = tableHeight - 2 * paddleHeight;

        const brickWidth = 100;
        const brickHeight = 20;
        const bricks = [];

        let autoPlay = false;
        let speedUp = false;
        let maxSpeed = 15;
        let intervalId;

        const adjustCanvasSize = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        };

        const handleMouseMove = (event) => {
            if (!autoPlay) {
                paddleX = event.clientX - canvas.getBoundingClientRect().left - paddleWidth / 2;
            }
        };

        const handleTouchMove = (event) => {
            if (!autoPlay) {
                paddleX = event.touches[0].clientX - canvas.getBoundingClientRect().left - paddleWidth / 2;
            }
        };

        const handleCanvasClick = () => {
            if (!gameStarted) {
                gameStarted = true;
            }
        };

        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('click', handleCanvasClick);

        window.addEventListener('resize', adjustCanvasSize);

        const toggleAutoPlay = () => {
            autoPlay = !autoPlay;
            if (autoPlay) {
                autoPlayButton.textContent = 'Manual Play';
                intervalId = setInterval(() => {
                    paddleX = puckX - paddleWidth / 2;
                    if (bricks.every((brick) => brick.broken)) {
                        startNextGame();
                        speedUp();
                    }
                }, 10);
            } else {
                autoPlayButton.textContent = 'Auto Play';
                clearInterval(intervalId);
            }
        };

        const toggleSpeed = () => {
            if (speedUp) {
                puckSpeedX = 5;
                puckSpeedY = 5;
                speedButton.textContent = 'Speed Up';
            } else {
                puckSpeedX = 15;
                puckSpeedY = 15;
                speedButton.textContent = 'Slow Down';
            }
            speedUp = !speedUp;
        };

        const generateBrickGrid = (rows, columns) => {
            const brickWidthWithPadding = 95;
            const brickHeightWithPadding = 20;
            const padding = 5;

            const totalGridWidth = columns * (brickWidthWithPadding + padding) - padding;
            const initialX = (tableWidth - totalGridWidth) / 2;
            const initialY = 5;

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < columns; j++) {
                    const brickX = initialX + j * (brickWidthWithPadding + padding);
                    const brickY = initialY + i * (brickHeightWithPadding + padding);

                    const randomColor = Math.random() < 0.1 ? 'green' : 'grey';

                    bricks.push({
                        x: brickX,
                        y: brickY,
                        width: brickWidthWithPadding - padding,
                        height: brickHeightWithPadding - padding,
                        broken: false,
                        color: randomColor,
                    });
                }
            }
        };

        const resetBricks = () => {
            bricks.length = 0;
            generateBrickGrid(5, 9);
        };

        resetBricks();

        const draw = () => {
            context.fillStyle = tableColor;
            context.fillRect(0, 0, tableWidth, tableHeight);

            if (gameStarted) {
                puckX += puckSpeedX;
                puckY += puckSpeedY;
            }

            context.fillStyle = puckColor;
            context.beginPath();
            context.arc(puckX, puckY, 10, 0, 2 * Math.PI);
            context.fill();

            context.fillStyle = paddleColor;
            context.fillRect(paddleX, paddleY, paddleWidth, paddleHeight);

            if (Math.floor(Date.now() / 1000) % 2 === 0) {
                bricks.forEach((brick) => {
                    if (!brick.broken) {
                        brick.color = Math.random() < 0.1 ? 'green' : 'grey';
                    }
                });
            }

            bricks.forEach((brick) => {
                if (!brick.broken) {
                    context.fillStyle = brick.color;
                    context.fillRect(brick.x, brick.y, brick.width, brick.height);
                }
            });

            if (puckY + 10 >= tableHeight) {
                gameOver();
            }

            if (puckY <= 0) {
                puckSpeedY = -puckSpeedY;
            }

            if (puckX <= 0 || puckX >= tableWidth) {
                puckSpeedX = -puckSpeedX;
            }

            if (
                puckY + 10 >= paddleY &&
                puckX >= paddleX &&
                puckX <= paddleX + paddleWidth
            ) {
                puckSpeedY = -puckSpeedY;
            }

            bricks.forEach((brick) => {
                if (!brick.broken) {
                    if (
                        puckY - 10 <= brick.y + brick.height &&
                        puckY - 10 >= brick.y &&
                        puckX >= brick.x &&
                        puckX <= brick.x + brick.width
                    ) {
                        if (brick.color === 'green') {
                            // Generate a new puck
                            puckX = brick.x + brick.width / 2;
                            puckY = brick.y + brick.height / 2;
                            puckSpeedX = Math.random() < 0.5 ? 5 : -5;
                            puckSpeedY = 5;
                        } else {
                            puckSpeedY = -puckSpeedY;
                            brick.broken = true;

                            if (bricks.every((brick) => brick.broken)) {
                                gameStarted = false;
                                nextGameButton.style.display = 'block';
                            }
                        }
                    }
                }
            });

            requestAnimationFrame(draw);
        };

        const gameOver = () => {
            context.clearRect(0, 0, tableWidth, tableHeight);
            gameOverMessage.textContent = 'Game Over';
            playAgainButton.style.display = 'block';
        };

        const startNextGame = () => {
            bricks.length = 0;
            generateBrickGrid(5, 9);
            gameOverMessage.textContent = '';
            playAgainButton.style.display = 'none';
            nextGameButton.style.display = 'none';
            puckX = tableWidth / 2;
            puckY = tableHeight / 2;
            puckSpeedX = 5;
            puckSpeedY = 5;
            gameStarted = true;
        };

        const resetGame = () => {
            bricks.length = 0;
            generateBrickGrid(5, 9);
            gameOverMessage.textContent = '';
            playAgainButton.style.display = 'none';
            nextGameButton.style.display = 'none';
            puckX = tableWidth / 2;
            puckY = tableHeight / 2;
            puckSpeedX = 5;
            puckSpeedY = 5;
            gameStarted = false;
        };

        draw();
    </script>
</body>

</html>
